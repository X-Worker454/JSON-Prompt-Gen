import {
  checkForHtmlHead,
  extractIcons,
  mapLink
} from "./chunk-BMKSJB47.js";
import {
  cyan,
  red
} from "./chunk-OKR3ZY3D.js";
import {
  require_promises
} from "./chunk-IIPIJRR4.js";
import {
  require_node_fs
} from "./chunk-7DNUXDXY.js";
import {
  require_node_path
} from "./chunk-QIDZU6WL.js";
import {
  __toESM
} from "./chunk-MYUJR7WL.js";

// node_modules/vite-plugin-pwa/dist/generator-Q3R7VIEH.js
var import_promises = __toESM(require_promises(), 1);

// optional-peer-dep:__vite-optional-peer-dep:@vite-pwa/assets-generator/api/generate-assets:vite-plugin-pwa
throw new Error(`Could not resolve "@vite-pwa/assets-generator/api/generate-assets" imported by "vite-plugin-pwa". Is it installed?`);

// node_modules/vite-plugin-pwa/dist/generator-Q3R7VIEH.js
var import_node_fs = __toESM(require_node_fs(), 1);
var import_promises2 = __toESM(require_promises(), 1);
var import_node_path = __toESM(require_node_path(), 1);

// optional-peer-dep:__vite-optional-peer-dep:@vite-pwa/assets-generator/api/instructions:vite-plugin-pwa
throw new Error(`Could not resolve "@vite-pwa/assets-generator/api/instructions" imported by "vite-plugin-pwa". Is it installed?`);

// optional-peer-dep:__vite-optional-peer-dep:@vite-pwa/assets-generator/config:vite-plugin-pwa
throw new Error(`Could not resolve "@vite-pwa/assets-generator/config" imported by "vite-plugin-pwa". Is it installed?`);

// optional-peer-dep:__vite-optional-peer-dep:@vite-pwa/assets-generator/api/generate-html-markup:vite-plugin-pwa
throw new Error(`Could not resolve "@vite-pwa/assets-generator/api/generate-html-markup" imported by "vite-plugin-pwa". Is it installed?`);

// optional-peer-dep:__vite-optional-peer-dep:@vite-pwa/assets-generator/api/generate-manifest-icons-entry:vite-plugin-pwa
throw new Error(`Could not resolve "@vite-pwa/assets-generator/api/generate-manifest-icons-entry" imported by "vite-plugin-pwa". Is it installed?`);

// node_modules/vite-plugin-pwa/dist/generator-Q3R7VIEH.js
async function generate(assetsGeneratorContext) {
  await (0, import_promises.mkdir)(assetsGeneratorContext.imageOutDir, { recursive: true });
  await (void 0)(assetsGeneratorContext.assetsInstructions, true, assetsGeneratorContext.imageOutDir);
}
async function loadAssetsGeneratorContext(ctx, assetsGeneratorContext) {
  var _a, _b, _c, _d;
  const root = ctx.viteConfig.root ?? process.cwd();
  const { config, sources } = await loadConfiguration(root, ctx);
  if (!config.preset) {
    console.error([
      "",
      cyan(`PWA v${ctx.version}`),
      red("ERROR: No preset for assets generator found")
    ].join("\n"));
    return;
  }
  const {
    preset,
    images,
    headLinkOptions: userHeadLinkOptions
  } = config;
  if (!images) {
    console.error([
      "",
      cyan(`PWA v${ctx.version}`),
      red("ERROR: No image provided for assets generator")
    ].join("\n"));
    return;
  }
  if (Array.isArray(images)) {
    if (!images.length) {
      console.error([
        "",
        cyan(`PWA v${ctx.version}`),
        red("ERROR: No image provided for assets generator")
      ].join("\n"));
      return;
    }
    if (images.length > 1) {
      console.error([
        "",
        cyan(`PWA v${ctx.version}`),
        red("ERROR: Only one image is supported for assets generator")
      ].join("\n"));
      return;
    }
  }
  const pwaAssets = ctx.options.pwaAssets;
  const useImage = Array.isArray(images) ? images[0] : images;
  const imageFile = await tryToResolveImage(root, sources, useImage);
  const publicDir = ((_a = pwaAssets.integration) == null ? void 0 : _a.publicDir) ?? (0, import_node_path.resolve)(root, ctx.viteConfig.publicDir || "public");
  const outDir = ((_b = pwaAssets.integration) == null ? void 0 : _b.outDir) ?? (0, import_node_path.resolve)(root, ((_c = ctx.viteConfig.build) == null ? void 0 : _c.outDir) || "dist");
  const imageName = (0, import_node_path.relative)(publicDir, imageFile);
  const imageOutDir = (0, import_node_path.dirname)((0, import_node_path.resolve)(outDir, imageName));
  const xhtml = (userHeadLinkOptions == null ? void 0 : userHeadLinkOptions.xhtml) === true;
  const includeId = (userHeadLinkOptions == null ? void 0 : userHeadLinkOptions.includeId) === true;
  const assetsInstructions = await (void 0)({
    imageResolver: () => (0, import_promises2.readFile)(imageFile),
    imageName,
    preset,
    faviconPreset: (userHeadLinkOptions == null ? void 0 : userHeadLinkOptions.preset) ?? pwaAssets.htmlPreset,
    htmlLinks: { xhtml, includeId },
    basePath: ((_d = pwaAssets.integration) == null ? void 0 : _d.baseUrl) || ctx.viteConfig.base || "/",
    resolveSvgName: (userHeadLinkOptions == null ? void 0 : userHeadLinkOptions.resolveSvgName) ?? ((name) => (0, import_node_path.basename)(name))
  });
  const {
    includeHtmlHeadLinks = true,
    overrideManifestIcons: useOverrideManifestIcons,
    injectThemeColor = false
  } = pwaAssets;
  const overrideManifestIcons = ctx.options.manifest === false || !ctx.options.manifest ? false : "icons" in ctx.options.manifest ? useOverrideManifestIcons : true;
  if (assetsGeneratorContext === void 0) {
    return {
      lastModified: Date.now(),
      assetsInstructions,
      cache: /* @__PURE__ */ new Map(),
      useImage,
      imageFile,
      publicDir,
      outDir,
      imageName,
      imageOutDir,
      xhtml,
      includeId,
      // normalize sources
      sources: sources.map((source) => source.replace(/\\/g, "/")),
      injectThemeColor,
      includeHtmlHeadLinks,
      overrideManifestIcons
    };
  }
  assetsGeneratorContext.lastModified = Date.now();
  assetsGeneratorContext.assetsInstructions = assetsInstructions;
  assetsGeneratorContext.useImage = useImage;
  assetsGeneratorContext.imageFile = imageFile;
  assetsGeneratorContext.outDir = outDir;
  assetsGeneratorContext.imageName = imageName;
  assetsGeneratorContext.imageOutDir = imageOutDir;
  assetsGeneratorContext.xhtml = xhtml;
  assetsGeneratorContext.includeId = includeId;
  assetsGeneratorContext.injectThemeColor = injectThemeColor;
  assetsGeneratorContext.includeHtmlHeadLinks = includeHtmlHeadLinks;
  assetsGeneratorContext.overrideManifestIcons = overrideManifestIcons;
  assetsGeneratorContext.cache.clear();
}
async function loadConfiguration(root, ctx) {
  const pwaAssets = ctx.options.pwaAssets;
  if (pwaAssets.config === false) {
    return await (void 0)(root, {
      config: false,
      preset: pwaAssets.preset,
      images: pwaAssets.images,
      logLevel: "silent"
    });
  }
  return await (void 0)(
    root,
    typeof pwaAssets.config === "boolean" ? root : { config: pwaAssets.config }
  );
}
async function checkFileExists(pathname) {
  try {
    await (0, import_promises2.access)(pathname, import_node_fs.default.constants.R_OK);
  } catch {
    return false;
  }
  return true;
}
async function tryToResolveImage(root, sources, image) {
  const imagePath = (0, import_node_path.resolve)(root, image);
  if (await checkFileExists(imagePath)) {
    return imagePath;
  }
  for (const source of sources) {
    const sourceImage = (0, import_node_path.resolve)((0, import_node_path.dirname)(source), image);
    if (await checkFileExists(sourceImage)) {
      return sourceImage;
    }
  }
  return imagePath;
}
async function findIconAsset(path, { assetsInstructions, cache, lastModified }) {
  let resolved = cache.get(path);
  if (resolved) {
    resolved.age = Date.now() - lastModified;
    return resolved;
  }
  const iconAsset = assetsInstructions.transparent[path] ?? assetsInstructions.maskable[path] ?? assetsInstructions.apple[path] ?? assetsInstructions.favicon[path] ?? assetsInstructions.appleSplashScreen[path];
  if (!iconAsset)
    return;
  if (iconAsset) {
    resolved = {
      path,
      mimeType: iconAsset.mimeType,
      buffer: iconAsset.buffer(),
      lastModified: Date.now(),
      age: 0
    };
    cache.set(path, resolved);
    return resolved;
  }
}
async function checkHotUpdate(file, ctx, assetsGeneratorContext) {
  const result = assetsGeneratorContext.sources.includes(file);
  if (result)
    await loadAssetsGeneratorContext(ctx, assetsGeneratorContext);
  return result;
}
function transformIndexHtml(html, ctx, assetsGeneratorContext) {
  if (assetsGeneratorContext.injectThemeColor) {
    const manifest = ctx.options.manifest;
    if (manifest && "theme_color" in manifest && manifest.theme_color) {
      html = checkForHtmlHead(html).replace(
        "</head>",
        `
<meta name="theme-color" content="${manifest.theme_color}"></head>`
      );
    }
  }
  if (assetsGeneratorContext.includeHtmlHeadLinks) {
    const link = (void 0)(assetsGeneratorContext.assetsInstructions);
    if (link.length)
      html = checkForHtmlHead(html).replace("</head>", `
${link.join("\n")}</head>`);
  }
  return html;
}
function resolveHtmlAssets(ctx, assetsGeneratorContext) {
  const header = {
    links: [],
    themeColor: void 0
  };
  if (assetsGeneratorContext.injectThemeColor) {
    const manifest = ctx.options.manifest;
    if (manifest && "theme_color" in manifest && manifest.theme_color)
      header.themeColor = { name: "theme-color", content: manifest.theme_color };
  }
  if (assetsGeneratorContext.includeHtmlHeadLinks) {
    const includeId = assetsGeneratorContext.includeId;
    const instruction = assetsGeneratorContext.assetsInstructions;
    const favicon = Array.from(Object.values(instruction.favicon));
    const apple = Array.from(Object.values(instruction.apple));
    const appleSplashScreen = Array.from(Object.values(instruction.appleSplashScreen));
    favicon.forEach((icon) => icon.linkObject && header.links.push(mapLink(includeId, icon.linkObject)));
    apple.forEach((icon) => icon.linkObject && header.links.push(mapLink(includeId, icon.linkObject)));
    appleSplashScreen.forEach((icon) => icon.linkObject && header.links.push(mapLink(includeId, icon.linkObject)));
  }
  return header;
}
function injectManifestIcons(ctx, assetsGeneratorContext) {
  if (!assetsGeneratorContext.overrideManifestIcons)
    return;
  const manifest = ctx.options.manifest;
  if (manifest) {
    manifest.icons = (void 0)(
      "object",
      assetsGeneratorContext.assetsInstructions
    ).icons;
  }
}
async function loadInstructions(ctx) {
  const assetsGeneratorContext = await loadAssetsGeneratorContext(ctx);
  if (!assetsGeneratorContext)
    return;
  return {
    generate: () => generate(assetsGeneratorContext),
    findIconAsset: (path) => findIconAsset(path, assetsGeneratorContext),
    resolveHtmlAssets: () => resolveHtmlAssets(ctx, assetsGeneratorContext),
    transformIndexHtml: (html) => transformIndexHtml(html, ctx, assetsGeneratorContext),
    injectManifestIcons: () => injectManifestIcons(ctx, assetsGeneratorContext),
    instructions: () => assetsGeneratorContext.assetsInstructions,
    icons: () => extractIcons(assetsGeneratorContext.assetsInstructions),
    checkHotUpdate: (file) => checkHotUpdate(file, ctx, assetsGeneratorContext)
  };
}
export {
  loadInstructions
};
//# sourceMappingURL=generator-Q3R7VIEH-2CVWDB66.js.map
